<h1>Atomic Operations</h1>

<ul>
    <li><a href="#atomicGet">AtomicGet</a></li>
    <li><a href="#atomicWeakGet">AtomicWeakGet</a></li>
    <li><a href="#atomicIncrement">AtomicIncrement</a></li>
</ul>

<h2 id="#atomicGet">Atomic Get</h2>
<a href="charts/atomic_get_line_wide.png"><img src="charts/atomic_get_line_narrow.png"/></a>
<a href="charts/atomic_get_line_wide_total.png"><img src="charts/atomic_get_line_total_narrow.png"/></a>

<h2 id="#atomicWeakGet">Atomic Weak Get</h2>
The atomicWeakGet is the cheapest get since it is atomic and doesn't obay any locking rules. So the only expensive
thing that needs to be done is volatile read.
<a href="charts/atomic_weak_get_line_wide.png"><img src="charts/atomic_weak_get_line_narrow.png"/></a>
<a href="charts/atomic_weak_get_line_total_wide.png"><img src="charts/atomic_weak_get_line_total_narrow.png"/></a>

<h2 id="#atomicIncrement">Atomic Increment</h2>
The performance of an AtomicLong.incrementAndGet. The performance is a bit higher than an ordinary uncontended update
caused by the overhead of the transaction and not acquiring the lock from the beginning.
<a href="charts/atomic_increment_line_wide.png"><img src="charts/atomic_increment_line_narrow.png"/></a>
<a href="charts/atomic_increment_line_total_wide.png"><img src="charts/atomic_increment_line_total_narrow.png"/></a>
<p/>
The performance of an uncontended AtomicLong.incrementAndGet. As you can see the performance of an ordinary AtomicLong
is quite a bit higher. This is related to the fact that in Multiverse, a cas is needed for acquiring the lock
and 3 volatile writes are needed (one for the value, one for the version and one for releasing the lock). For the
0.8 release there are some experiments planned for removing one of the volatile writes.
<a href="charts/atomic_long_increment_line_wide.png"><img src="charts/atomic_long_increment_line_narrow.png"/></a>
<a href="charts/atomic_long_increment_line_total_wide.png"><img src="charts/atomic_long_increment_line_total_narrow.png"/></a>

