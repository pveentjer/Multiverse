<h1>Multiverse 0.6</h1>

Multiverse 0.6 release currently is under development and expected around the end of June 2010. The main focus will
not be on adding new features, but on improving scalability, performance and stability.
<p>
    The expected features are:
<ol>
    <li>
        Profiling support for txn and transactional object level behavior. Information will be made
        available by writing a report to file periodically. In the future more advanced profiling mechanisms
        will be added, but this should shed some light in the darkness.
    </li>
    <li>
        New bytecode optimizations:
        <ul>
            <li>
                speculative inlining of txns: removing the creation of the txn object and inlining
                it completely in simple methods. Based on experiments, this should give a big performance boost.
            </li>
            <li>
                transactional objects as arguments: once the tranlocal is retrieved it can be stored for later use
                and can be added as extra arguments by widening the methods in the instrumentation. This reduces
                unwanted access to the txn and improves the chance for the JIT to do its magic.
            </li>
            <li>
                removing junk instructions: atm some swaps and duplications of operand-stack elements are needed to
                access the owning transactional object and thus cause some bytecode noise. Some of this noise will be
                removed for the 0.6 release so that the JIT has a better chance to do its magic.
            </li>
        </ul>
    </li>
    <li>
        Transaction reuse: instead of creating a new txn every time a transactional method is executed,
        an old one can be reset and reused.
    </li>
    <li>
        Better scalable clock. Multiverse 0.5 uses a shared (by all txns of the same STM) AtomicLong as
        clock that needs to be incremented by every update txn (that has updates of course). In 0.5
        the tick to the clock is optimized in such a way that concurrent ticks don't need to lead to unique
        timestamp. (this already removes a lot of pressure on the memory bus). But the 0.6 release is going to have
        a configurable 'sync to clock' property that relaxes the updating of central clock. This should make the
        STM more scalable for unshared data structures.
    </li>
    <li>
        New transactional collections:
        <ul>
            <li>TransactionalTreeMap</li>
            <li>TransactionalTreeSet</li>
        </ul>
    </li>
    <li>
        Groovy integration.
    </li>
    <li>
        Compatible with Scala/Akka. In principle nothing special needs to be done for a class generated
        by Scala compiler to be instrumented; from a bytecode perspective it should be the same as a class
        generated by the Java compiler. But there always are small exceptions that cause problems. The goal
        is to make Multiverse Scala/Akka compatible.
    </li>
    <li>
        Continuous performance integration environment. It should be easy to create benchmarks, store results
        and compare them over time (to do trans analysis). This is needed for the Multiverse project itself to make
        sure that the performance doesn't degrade.
    </li>
    <li>
        Bugshaker: a javaagent that increase the chance of concurrency problems to happen by adding random delays
        at critical sections in the system or user code (probably using some kind of annotation).
    </li>
</ol>